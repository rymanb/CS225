                                Lazy-copy programming assignment

Futurama season 3, episode 12 (change "alcohol" to "shallow copy" and "21" for "this class").
+--------------------------------------------------------------------------+
|Leela: Actually, Dwight, you're right. Alcohol is very, very bad ... for  |
|children. But once you turn 21 it becomes very, very good. So scram!      |
+--------------------------------------------------------------------------+

The goal of this project is to get familiar with popular C++ design patterns/techniques:
       reference counting
       virtual constructors (aka Prototype pattern) - see lecture slides
       factory pattern - implemented, read handout and use it.


Reference counting is very general technique used in various areas in computer
science. One of the most famous applications is in garbage collection
algorithms. See, for example, http://en.wikipedia.org/wiki/Reference_counting.
We'll use reference counting to implement lazy-copy algorithm. 

It's easy to see that many copies (especially those generated by the compiler
to pass or return by value) are never modified, thus it's a waste of both
time and space (memory) to perform deep copy each time a copy is requested. We
would rather be lazy and BY DEFAULT create a shallow copy of the object
(something we were avoiding before) and hope that neither original nor copy
will ever be modified (thus allowing them to have shared data). 

If we were correct and neither of the two objects that shared data was never
modified before at least one of them was deleted, then to harm is done and
everything is good. 

But if we are wrong and one of them is modified (while both are alive), a deep
copy must be performed - so that the two object get separated and the above
modification only changes one of them, leaving the other unchanged.  This is
called *late-copy* or *copy-on-write*. 

If you were careful and marked all non-modifying methods with "const", then the
rule is:
- all methods with const do not require deep copy (and operate correctly on shared data)
- all  methods without const should first make sure that noone else is using
  this data: if there are other object that use this data - perform deep copy
  first, if data is not shared - proceed without deep copy.

The key feature of this implementation is a reference counter - an integer value
that keeps track of how many object are *looking* at this data. Notice that 
the actual integer counter value is a part of data, and objects have pointers 
to the data and counters.

Functionality:

1) Objects created by a non-copy ctors start with ref_count set to 1. 
2) If copy ctor or assignment is called, we just increment the counter of the 
   data that is copied or assigned and perform only the SHALLOW copy. 
3) If dtor is called, decrement the counter, if it becomes zero - delete data.
4) If a const method is called - just perform operation, it is not modifying 
   the data, therefor can be executed on the shared data.
5) If non-const method is called 
  - if ref_count == 1, then the current object is the only one referencing the data,
    thus it is the only owner, so all modifications of the data may be performed
    right away.
  - otherwise (>1), the data is shared, thus if we modify data, than more then
    1 object will see the change - something we want to avoid, so we need to
    "fork" - we need both objects to have their own version of data. That is a 
    deep copy is required. If the object had reference count N, then 
    after the "split" the original object has the counter 1 (i.e. has its own data) 
    and the counter on the old data is N-1.
  - special case - dtor, if ref_counter

Diagram is 2 objects sharing data, notice counter is 2.

     +------------+
obj1 | data* int* | 
     +------------+
         |   |
         |   +-------------------------V
         +-----------> +------+ +-----------+
                       | data | | counter=2 |   
         +-----------> +------+ +-----------+
         |   +-------------------------^
         |   |
     +------------+
obj2 | data* int* | 
     +------------+


Diagram is an object that does not share data, notice counter is 1.

                       +------+ +-----------+
                       | data | | counter=1 |   
         +-----------> +------+ +-----------+
         |   +-------------------------^
         |   |
     +------------+
obj3 | data* int* | 
     +------------+





========================================================================
     Example:

first object is created 
C obj1;
                       +------+ +-----------+
                       | data | | counter=1 |   
         +-----------> +------+ +-----------+
         |   +-------------------------^
         |   |
     +------------+
obj1 | data* int* | 
     +------------+

Second object is copy constructed:
C obj2(obj1);

     +------------+
obj1 | data* int* | 
     +------------+
         |   |
         |   +-------------------------V
         +-----------> +------+ +-----------+
                       | data | | counter=2 |   
         +-----------> +------+ +-----------+
         |   +-------------------------^
         |   |
     +------------+
obj2 | data* int* | 
     +------------+


First object is modified
obj1.modify();

                       +------+ +-----------+
                       | data | | counter=1 |   
         +-----------> +------+ +-----------+
         |   +-------------------------^
         |   |
     +------------+
obj1 | data* int* | 
     +------------+

                       +------+ +-----------+
                       | data | | counter=1 |   
         +-----------> +------+ +-----------+
         |   +-------------------------^
         |   |
     +------------+
obj2 | data* int* | 
     +------------+

========================================================================
     Another example:

returning by value from a subroutine:

C foo() { C obj; ....., return obj; } // "....." added to shut down RVO


C obj;

                 +------+ +-----------+
                 | data | | counter=1 |   
   +-----------> +------+ +-----------+
   |   +-------------------------^
   |   |
+--|---|----+
| +------+  | 
| | obj  |  |  
| +------+  |
+-----------+
 foo stack


return obj;
as you remember there will be a temporary, but in our case
it will be a shallow copy of obj in foo stack
                 +------+ +-----------+
                 | data | | counter=2 |   
   +-----------> +------+ +-----------+
   |   +------------^------------^
   |   |            |            |
+--|---|----+       |            |
| +------+  |       |            |
| | obj  |  |       |            |
| +------+  |       |            |
+-----------+       |            |
 foo stack          |            |
                    |            |
+------+------------+            |
| temp |-------------------------+
+------+



then foo stack (and foo's obj) is deleted:
                 +------+ +-----------+
                 | data | | counter=1 |   
                 +------+ +-----------+
                    ^            ^
                    |            |
                    |            |
                    |            |
                    |            |
                    |            |
                    |            |
                    |            |
                    |            |
+------+------------+            |
| temp |-------------------------+
+------+

BUT the temporary is using the same data that was allocated by obj.

in main:   C obj=foo();
Temporary is assigned to a local variable inside "main"
                 +------+ +-----------+
                 | data | | counter=2 |   
   +-----------> +------+ +-----------+
   |   +------------^------------^
   |   |            |            |
+--|---|----+       |            |
| +------+  |       |            |
| | obj  |  |       |            |
| +------+  |       |            |
+-----------+       |            |
 main stack         |            |
                    |            |
+------+------------+            |
| temp |-------------------------+
+------+

temporary is deleted:
                 +------+ +-----------+
                 | data | | counter=1 |   
   +-----------> +------+ +-----------+
   |   +-------------------------^
   |   |      
+--|---|----+ 
| +------+  | 
| | obj  |  | 
| +------+  | 
+-----------+ 
 main stack   


still using the same data that was allocated a long time ago!!!!!
Which means that a class with referencing counting implements RVO (almost -
most of the data is not copied, but a couple of pointer will be)


===============================================================================
    Object factory. 

One of the problems in software design is the "tight-coupling" of software
components. Usually that means that components are name-dependent on each
other, so that modification of one of the components causes a chain of
modifications in many name-dependent components. 

For example - in this assignment we have 2
classes Element1 and Element2 declared in files element1.h and element2.h.
And class Array (file array.cpp) uses both of them:

//BAD IMPLEMENTATION
void CS225::Array::Set(int id, int pos, int value) { 
  if      (id==1) data[pos]=new Element1(value); // class name Element1 is used - then corresponding header MUST be included
  else if (id==2) data[pos]=new Element2(value); // class name Element2 is used - then corresponding header MUST be included
}

therefore "array.cpp" has to include
#include "element1.h" 
#include "element2.h" 
Which creates the name dependency.

The problem with name-dependencies is that if element*.h header is modified -
for example a name of a method is modified or a new type element is created,
then since this name (or new type) is used by Array, someone has to update
array.cpp and RECOMPILE it. Since some of the headers are included in a lot
of files, any modification of those headers will cause a big wave of
recompiles.

Simplest scenario which will cause a wave of recompiles is an attempt to add
a new class Element3:

//BAD IMPLEMENTATION
void CS225::Array::Set(int id, int pos, int value) { 
  if      (id==1) data[pos]=new Element1(value);
  else if (id==2) data[pos]=new Element2(value);
  // add new line
  else if (id==3) data[pos]=new Element3(value); //corresponding header file should also be added
}

as you see above, the process of adding of a new type requires a significant 
modification of array.cpp.

Here is a diagram of includes:

            array.cpp
            /      \
           /        \
     Element1.h Element2.h 

Solution: to allow class Array to be extended (with new element-like types), 
but not require modifications of array.cpp we may use Factory pattern. 

The idea is - factor out all code that has to "know" about Element classes
into its own class (ElementFactory) and pass a ElementFactory* (pointer)
to Array. Now:
 - array.cpp uses ElementFactory class interface defined in "element-factory.h"
 - ElementFactory class interface is implemented in element-factory.cpp which 
   has to include element1.h and element2.h

But there is no direct path from array.cpp to elements, thus no dependency.

Here is a diagram of includes:

                array.cpp
               /
              /
element-factory.h                 element-factory.cpp
                                       /      \
                                      /        \
                                element1.h element2.h


Roadmap:
    1. implement Arrays with deep copy ctor and assignment (no reference counting). Notice that you have to 
        a. implement AbstractElement class
        b. implement virtual constructors for Element1 and Element2. 
    2. once the above is tested, implement reference counting. You may want to
       have 2 helper methods (make them private or protected) something like
       DeleteData (content of the old dtor) and DeepCopy (content of the deep copy and assignment). 
    3. Check if you have #include "element1.h" in your "array.cpp". If you do - 
       make sure to use Factory instead of using Element1 directly.

To submit:
----------
array.cpp
array.h
element1.cpp
element1.h
element2.cpp
element2.h
abstract-element.h
