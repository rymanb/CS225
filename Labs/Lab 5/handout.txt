Implement Shape hierarchy for a simplictic "ray tracing"
=======================================================

Read text below, study driver.cpp

Note:
 - shapes.cpp is completely implemented

To submit:
 - shapes.h -  you have to figure out how to declare all the classes, check
               shapes.cpp first, no implementation is required for this file,
               just declarations
 - trace.cpp - implement a single global function that finds the *first* 
               intersection of a given ray with a set of objects. 
               Your implementation will try to intersect the given ray 
               with every object in the set and then choose the first 
               (i.e. earliest time).
               Note that Intersect functions return
               std::pair<bool,float> Box::Intersect
               where bool - intersected or not
               float      - time of intersection.


Basic idea:
Box is an axis-aligned rectangle defined by center and sides' lengthes:

+----------------------+
|                      |  s
|                      |  i
|                      |  d
|        cx,cy         |  e
|                      |  _
|                      |  y
|                      | 
+----------------------+
        side_x

Thus vertices of a Box are 
(cx + side_x/2, cy + side_y/2) 
(cx + side_x/2, cy - side_y/2) 
(cx - side_x/2, cy + side_y/2) 
(cx - side_x/2, cy - side_y/2) 

Bounding circle of a Box has center at (cx,cy) and it's radius is a half of
the Box's diagonal.

Rhombus is defined by center and diagonal' lengths, it's diagonals are axis-aligned:

      +
     /|\
    / | \
   /  |  \
  /   |<---------diag_y
 /    |    \
+--c_x,c_y--+
 \    |   ^ /
  \   |   |
   \  |  /|
    \ | / |
     \|/  diag_x
      +

Thus vertices of a Rhombus are 
(cx           , cy + diag_y/2) 
(cx           , cy - diag_y/2) 
(cx - diag_x/2, cy           ) 
(cx + diag_x/2, cy           ) 

Bounding circle of a Rhombus has center at (cx,cy) and it's radius is a half of
the larger diagonal.

Bounding circle is used as a simple test whether ray intersects a shape: since
bounding circle includes the shape (area-wise), then if the ray does not 
intersects the circle, it also cannot intersect the shape. 

If the ray has an intersection with circle then we have to perform a more 
complicated intersection test using the actual shape data.

For example to detect ray-circle intersection we may perform a single distance 
from center to line calculation and if the distance is greater then the radius,
then there is no intersection (see implementation of 
BoundingCircle::IntersectTest for details.)

If BoundingCircle::IntersectTest returns true, then we have to perform a more expensive
intersection test using the actual shape, which requires 4 (both Box and Rhombus
have 4 sides) ray-segment intersection calculations.

Thus the strategy for intersection testing is:

if ( ray intersects bounding circle ) {
    if ( ray intersects actual shape ) { // cheap
        ....;                            // expensive
    } else {
        ...; //no intersection
} else {
     ...; //no intersection
}

